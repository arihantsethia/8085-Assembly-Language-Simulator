# 8085-Assembly-Language-Simulator

Prerequisites 
------------------------ 
Thing you need to run this software :

1) Python 2.5+ (Might not work with Python 3.0+)

2) Ubuntu 10.04 and above 

About The Software
------------------------ 
An assembly language is a machine dependent, low level programming language which is specific to a certain computer system. It has three basic features â€“ Mnemonic operation codes, Symbolic operands, and Data declarations. Our software aims at converting simple assembly language code defined on an instruction set into 8085 assembly code, linking different files and their variables and loading it in appropriate location in the memory as defined by the user. It involves three basic functions- Assembling, Linking and Loading.

An Assembler converts an assembly language code to an object file or machine language format. An assembler creates object code by translating assembly instruction mnemonics into op-codes, and by resolving symbolic names for memory locations and other entities. The use of symbolic references is a key feature of assemblers, saving tedious calculations and manual address updates after program modifications. Along with this it also includes features of converting macros (a unit of specification for program generation through expansion).

A Linker takes one or more object files generated by an assembler and combine them into a single executable program. It allows object files to use symbols defined in other modules or other files. The linker processes a set of object modules to produce a ready-to-execute program form, which we will call a binary program.

A Loader is responsible for loading programs for the purpose of execution. It is one of the essential stages in the process of starting a program, as it places programs into memory and prepares them for execution. Loading a program involves reading the contents of executable files, the file containing the program text, into memory, and then carrying out other required preparatory tasks to prepare the executable for running.

Steps to run the program
------------------------
1) Open the terminal and type :

```bash
	$ python main.py
```

2) Now, enter the relative path address of the files on prompt.

3) Various files are generated after each phase is processed.

4) After this you would be asked to load the files at different addresses.


Instruction Set:
------------------------
The instruction set contains all the instructions predefined in 8085-Assembly. Apart from that there a dozen more instructions defined to make programming easier.

- **`ADDMM &m1,&m2,&m3`**: Add 2 numbers stored in 'm2'  and 'm3'  memory locations. Stack
starts from 'm1'  memory location

- **`ADDMR &m1,&m2`**: Add number in the register to the number in 'm2'  memory. Stack
starts from 'm1'  memory location

- **`ADDVV &m1,&m2,v1,v2`**: Add 2 variables 'v1'  and 'v2'  and store in 'm2'  memory location. Stack
starts from 'm1'  memory location

- **`ADDVR &m1,&m2,v1`**: Add variable 'v1'  to number stored in 'm2'  memory location. Stack
starts from 'm1'  memory location

- **`SUBMM &m1,&m2,&m3`**: Subtract numbers stored in 'm3'  from 'm2'  memory location. Stack
starts from 'm1'  memory location

- **`SUBMR &m1,&m2`**: Subtract number in register from number in 'm2'  memory location.
Stack starts from 'm1'  memory location

- **`SUBVV &m1,&m2,v1,v2`**: Subtract 2 variable 'v2'  from 'v1'  and store in 'm2'  memory location.
Stack starts from 'm1'  memory location

- **`SUBVR &m1,&m2,v1`**: Subtract variable 'v1'  from number stored in 'm2'  memory location.
Stack starts from 'm1'  memory location

- **`MINM &m1,&m2`**: Find minimum between the numbers stored in 2 memory locations

- **`MAXM &m1,&m2`**: Find maximum between the numbers stored in 2 memory locations

- **`MINMM &m1,&m2,&m3`**: Find minimum among the numbers stored in 3 memory locations

- **`MAXMM &m1,&m2,&m3`**: Find maximum among the numbers stored in 3 memory locations

- **`SWP &m1,&m2`**: Swap the elements present in 2 memory locations

- **`MUT &m1, &m2`**: Multiply a number at memory location 'm2'  with 2. Stack starts from
memory location m1


How Does It Work ?
------------------------
### Input
Software accepts multiple assembly files written using the defined instruction set.

### Assembler - Pass1
In this part the input codes are converted to native 8085 code. Macros expansion is also taken care in here. To ease the programming for user, user can use his predefined macros within another macro.

### Assembler - Pass2
Symbol Table for each file is generated and is stored in `filename.table`. After this all the labels are replaced by relative address values.

### Linker
Extern variables are handled in here. All the files are linked with each other.

### Loader
The user is asked for the memory location where he wants to load his program. The programs are then dynamically loaded into those specific memory locations.The ouput of `filename.s.8085` file can then be run on [GnuSim8085](http://gnusim8085.org/)

### Files generated by the program

- **filename.pre**: This is the file generated after preprocessing i.e after replacing all the occurrences of Macros and Custom Opcode with the corresponding 8085 instruction set.

- **filename.table**: This file contains info about all the Macros, Symbols, Labels, Variables. This file generation is completed after Pass 1.

- **filename.s**: This file contains the assembled code. 

- **filename.l.8085**: This file contains the code after linking.

- **filename.8085**: File generated after the linked file is loaded at the provided addresses.

### Sample Codes
Two sample codes can be found in **codes** directory

